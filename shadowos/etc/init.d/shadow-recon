#!/bin/sh
# ShadowOS Stealth Recon Daemon
# /etc/init.d/shadow-recon
#
# Automatic passive network reconnaissance
# Updates ~/Desktop/interesting_neighbours.txt

### BEGIN INIT INFO
# Provides:          shadow-recon
# Required-Start:    $network shadowos
# Required-Stop:
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
### END INIT INFO

PIDFILE=/var/run/shadow-recon.pid
OUTPUT="${HOME:-/root}/Desktop/interesting_neighbours.txt"
SCAN_INTERVAL=300  # 5 minutes

log() { echo "[recon] $*"; }

# =============================================================================
# STEALTH SCANNING TECHNIQUES
# =============================================================================

# Passive ARP monitoring (completely silent)
passive_arp_scan() {
    timeout 30 tcpdump -i any -nn -e arp 2>/dev/null | \
        grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}' | sort -u
}

# Slow SYN scan with randomized timing (evades IDS)
stealth_port_scan() {
    local target="$1"
    local ports="21,22,23,25,53,80,110,139,443,445,3389,8080"
    
    # Random delay between probes, fragmented packets
    nmap -sS -Pn -n --max-retries 1 --scan-delay 500ms \
         --max-scan-delay 2s -f --data-length 24 \
         -p "$ports" "$target" 2>/dev/null | grep "open"
}

# Passive OS fingerprinting from traffic
passive_os_detect() {
    local target="$1"
    # Analyze TTL and window size from observed traffic
    timeout 10 tcpdump -i any -c 5 host "$target" 2>/dev/null | \
        grep -oE 'ttl [0-9]+' | head -1
}

# DNS-based discovery (no direct contact)
dns_recon() {
    local network="$1"
    # Reverse DNS lookups
    for i in $(seq 1 254); do
        host "${network}.${i}" 2>/dev/null | grep "pointer" &
    done
    wait
}

# Detect interesting services
identify_interesting() {
    local ip="$1"
    local ports="$2"
    local score=0
    local tags=""
    
    echo "$ports" | grep -q "22" && { score=$((score+1)); tags="$tags SSH"; }
    echo "$ports" | grep -q "80\|443\|8080" && { score=$((score+2)); tags="$tags WEB"; }
    echo "$ports" | grep -q "445\|139" && { score=$((score+3)); tags="$tags SMB"; }
    echo "$ports" | grep -q "3389" && { score=$((score+2)); tags="$tags RDP"; }
    echo "$ports" | grep -q "21" && { score=$((score+1)); tags="$tags FTP"; }
    echo "$ports" | grep -q "23" && { score=$((score+2)); tags="$tags TELNET"; }
    echo "$ports" | grep -q "3306\|5432\|1433" && { score=$((score+3)); tags="$tags DB"; }
    
    echo "$score|$tags"
}

# =============================================================================
# FIREWALL EVASION TECHNIQUES
# =============================================================================

evade_scan() {
    local target="$1"
    local method=$((RANDOM % 4))
    
    case $method in
        0) # Fragmented packets
            nmap -sS -Pn -n -f --mtu 16 "$target" -p 80,443 2>/dev/null
            ;;
        1) # Decoy scan
            nmap -sS -Pn -n -D RND:5 "$target" -p 80,443 2>/dev/null
            ;;
        2) # Idle/zombie scan (if zombie found)
            nmap -sS -Pn -n --source-port 53 "$target" -p 80,443 2>/dev/null
            ;;
        3) # Slow scan with random timing
            nmap -sS -Pn -n -T1 --randomize-hosts "$target" -p 80,443 2>/dev/null
            ;;
    esac
}

# =============================================================================
# MAIN RECON LOOP
# =============================================================================

recon_daemon() {
    log "Starting stealth recon daemon..."
    
    mkdir -p "$(dirname "$OUTPUT")"
    
    while true; do
        # Get current network
        local gateway=$(ip route | grep default | awk '{print $3}' | head -1)
        [ -z "$gateway" ] && { sleep 60; continue; }
        
        local network=$(echo "$gateway" | sed 's/\.[0-9]*$//')
        local timestamp=$(date '+%Y-%m-%d %H:%M')
        
        log "Scanning network $network.0/24..."
        
        # Collect neighbours
        {
            echo "# Interesting Neighbours - Updated: $timestamp"
            echo "# Network: $network.0/24"
            echo "# Gateway: $gateway"
            echo ""
            echo "IP Address      | Score | Services"
            echo "----------------|-------|------------------"
        } > "$OUTPUT.tmp"
        
        # Passive discovery first
        local hosts=$(passive_arp_scan)
        
        # If no passive results, do quiet ARP scan
        [ -z "$hosts" ] && hosts=$(arp-scan -l -q 2>/dev/null | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}')
        
        # Scan each host stealthily
        for host in $hosts; do
            [ "$host" = "$gateway" ] && continue
            
            # Evade firewall and scan
            local ports=$(evade_scan "$host" | grep "open" | awk '{print $1}' | tr '\n' ',')
            
            if [ -n "$ports" ]; then
                local result=$(identify_interesting "$host" "$ports")
                local score=$(echo "$result" | cut -d'|' -f1)
                local tags=$(echo "$result" | cut -d'|' -f2)
                
                # Only show interesting hosts (score > 0)
                if [ "$score" -gt 0 ]; then
                    printf "%-15s | %5s | %s\n" "$host" "$score" "$tags" >> "$OUTPUT.tmp"
                fi
            fi
            
            # Random delay to avoid detection
            sleep $((RANDOM % 3 + 1))
        done
        
        # Sort by score (most interesting first)
        {
            head -6 "$OUTPUT.tmp"
            tail -n +7 "$OUTPUT.tmp" | sort -t'|' -k2 -rn
        } > "$OUTPUT"
        
        rm -f "$OUTPUT.tmp"
        
        log "Scan complete. Found $(wc -l < "$OUTPUT") interesting hosts."
        
        # Wait before next scan
        sleep $SCAN_INTERVAL
    done
}

case "$1" in
    start)
        if [ -f "$PIDFILE" ]; then
            log "Already running"
            exit 1
        fi
        recon_daemon &
        echo $! > "$PIDFILE"
        log "Started (PID: $!)"
        ;;
    stop)
        [ -f "$PIDFILE" ] && kill $(cat "$PIDFILE") 2>/dev/null
        rm -f "$PIDFILE"
        log "Stopped"
        ;;
    restart)
        $0 stop
        sleep 1
        $0 start
        ;;
    *)
        echo "Usage: $0 {start|stop|restart}"
        ;;
esac
